{"ast":null,"code":"import \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport { createVNode as _createVNode } from \"vue\";\n// Styles\nimport \"./VSlideGroup.css\"; // Components\n\nimport { VFadeTransition } from \"../transitions/index.mjs\";\nimport { VIcon } from \"../VIcon/index.mjs\"; // Composables\n\nimport { IconValue } from \"../../composables/icons.mjs\";\nimport { makeGroupProps, useGroup } from \"../../composables/group.mjs\";\nimport { makeTagProps } from \"../../composables/tag.mjs\";\nimport { useDisplay } from \"../../composables/index.mjs\";\nimport { useResizeObserver } from \"../../composables/resizeObserver.mjs\";\nimport { useRtl } from \"../../composables/rtl.mjs\"; // Utilities\n\nimport { bias, calculateCenteredOffset, calculateUpdatedOffset } from \"./helpers.mjs\";\nimport { clamp, defineComponent, IN_BROWSER, useRender } from \"../../util/index.mjs\";\nimport { computed, ref, watch } from 'vue'; // Types\n\nexport const VSlideGroupSymbol = Symbol.for('vuetify:v-slide-group');\nexport const VSlideGroup = defineComponent({\n  name: 'VSlideGroup',\n  props: {\n    centerActive: Boolean,\n    direction: {\n      type: String,\n      default: 'horizontal'\n    },\n    symbol: {\n      type: null,\n      default: VSlideGroupSymbol\n    },\n    nextIcon: {\n      type: IconValue,\n      default: '$next'\n    },\n    prevIcon: {\n      type: IconValue,\n      default: '$prev'\n    },\n    showArrows: {\n      type: [Boolean, String],\n      validator: v => typeof v === 'boolean' || ['always', 'desktop', 'mobile'].includes(v)\n    },\n    ...makeTagProps(),\n    ...makeGroupProps({\n      selectedClass: 'v-slide-group-item--active'\n    })\n  },\n  emits: {\n    'update:modelValue': value => true\n  },\n  setup(props, _ref) {\n    let {\n      slots\n    } = _ref;\n    const {\n      isRtl\n    } = useRtl();\n    const {\n      mobile\n    } = useDisplay();\n    const group = useGroup(props, props.symbol);\n    const isOverflowing = ref(false);\n    const scrollOffset = ref(0);\n    const containerSize = ref(0);\n    const contentSize = ref(0);\n    const isHorizontal = computed(() => props.direction === 'horizontal');\n    const {\n      resizeRef: containerRef,\n      contentRect: containerRect\n    } = useResizeObserver();\n    const {\n      resizeRef: contentRef,\n      contentRect\n    } = useResizeObserver();\n    const firstSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1;\n      return group.items.value.findIndex(item => item.id === group.selected.value[0]);\n    });\n    const lastSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1;\n      return group.items.value.findIndex(item => item.id === group.selected.value[group.selected.value.length - 1]);\n    });\n    if (IN_BROWSER) {\n      let frame = -1;\n      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {\n        cancelAnimationFrame(frame);\n        frame = requestAnimationFrame(() => {\n          if (containerRect.value && contentRect.value) {\n            const sizeProperty = isHorizontal.value ? 'width' : 'height';\n            containerSize.value = containerRect.value[sizeProperty];\n            contentSize.value = contentRect.value[sizeProperty];\n            isOverflowing.value = containerSize.value + 1 < contentSize.value;\n          }\n          if (firstSelectedIndex.value >= 0 && contentRef.value) {\n            // TODO: Is this too naive? Should we store element references in group composable?\n            const selectedElement = contentRef.value.children[lastSelectedIndex.value];\n            if (firstSelectedIndex.value === 0 || !isOverflowing.value) {\n              scrollOffset.value = 0;\n            } else if (props.centerActive) {\n              scrollOffset.value = calculateCenteredOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                isHorizontal: isHorizontal.value\n              });\n            } else if (isOverflowing.value) {\n              scrollOffset.value = calculateUpdatedOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                currentScrollOffset: scrollOffset.value,\n                isHorizontal: isHorizontal.value\n              });\n            }\n          }\n        });\n      });\n    }\n    const disableTransition = ref(false);\n    let startTouch = 0;\n    let startOffset = 0;\n    function onTouchstart(e) {\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY';\n      startOffset = scrollOffset.value;\n      startTouch = e.touches[0][sizeProperty];\n      disableTransition.value = true;\n    }\n    function onTouchmove(e) {\n      if (!isOverflowing.value) return;\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY';\n      scrollOffset.value = startOffset + startTouch - e.touches[0][sizeProperty];\n    }\n    function onTouchend(e) {\n      const maxScrollOffset = contentSize.value - containerSize.value;\n      if (isRtl.value) {\n        if (scrollOffset.value > 0 || !isOverflowing.value) {\n          scrollOffset.value = 0;\n        } else if (scrollOffset.value <= -maxScrollOffset) {\n          scrollOffset.value = -maxScrollOffset;\n        }\n      } else {\n        if (scrollOffset.value < 0 || !isOverflowing.value) {\n          scrollOffset.value = 0;\n        } else if (scrollOffset.value >= maxScrollOffset) {\n          scrollOffset.value = maxScrollOffset;\n        }\n      }\n      disableTransition.value = false;\n    }\n    function onScroll() {\n      containerRef.value && (containerRef.value.scrollLeft = 0);\n    }\n    const isFocused = ref(false);\n    function onFocusin(e) {\n      isFocused.value = true;\n      if (!isOverflowing.value || !contentRef.value) return; // Focused element is likely to be the root of an item, so a\n      // breadth-first search will probably find it in the first iteration\n\n      for (const el of e.composedPath()) {\n        for (const item of contentRef.value.children) {\n          if (item === el) {\n            scrollOffset.value = calculateUpdatedOffset({\n              selectedElement: item,\n              containerSize: containerSize.value,\n              contentSize: contentSize.value,\n              isRtl: isRtl.value,\n              currentScrollOffset: scrollOffset.value,\n              isHorizontal: isHorizontal.value\n            });\n            return;\n          }\n        }\n      }\n    }\n    function onFocusout(e) {\n      isFocused.value = false;\n    }\n    function onFocus(e) {\n      var _contentRef$value;\n      if (!isFocused.value && !(e.relatedTarget && (_contentRef$value = contentRef.value) != null && _contentRef$value.contains(e.relatedTarget))) focus();\n    }\n    function onKeydown(e) {\n      if (!contentRef.value) return;\n      if (e.key === (isHorizontal.value ? 'ArrowRight' : 'ArrowDown')) {\n        focus('next');\n      } else if (e.key === (isHorizontal.value ? 'ArrowLeft' : 'ArrowUp')) {\n        focus('prev');\n      } else if (e.key === 'Home') {\n        focus('first');\n      } else if (e.key === 'End') {\n        focus('last');\n      }\n    }\n    function focus(location) {\n      if (!contentRef.value) return;\n      if (!location) {\n        var _focusable$;\n        contentRef.value.querySelector('[tabindex]');\n        const focusable = [...contentRef.value.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])')].filter(el => !el.hasAttribute('disabled'));\n        (_focusable$ = focusable[0]) == null ? void 0 : _focusable$.focus();\n      } else if (location === 'next') {\n        var _contentRef$value$que;\n        const el = (_contentRef$value$que = contentRef.value.querySelector(':focus')) == null ? void 0 : _contentRef$value$que.nextElementSibling;\n        if (el) el.focus();else focus('first');\n      } else if (location === 'prev') {\n        var _contentRef$value$que2;\n        const el = (_contentRef$value$que2 = contentRef.value.querySelector(':focus')) == null ? void 0 : _contentRef$value$que2.previousElementSibling;\n        if (el) el.focus();else focus('last');\n      } else if (location === 'first') {\n        var _contentRef$value$fir;\n        (_contentRef$value$fir = contentRef.value.firstElementChild) == null ? void 0 : _contentRef$value$fir.focus();\n      } else if (location === 'last') {\n        var _contentRef$value$las;\n        (_contentRef$value$las = contentRef.value.lastElementChild) == null ? void 0 : _contentRef$value$las.focus();\n      }\n    }\n    function scrollTo(location) {\n      const sign = isRtl.value ? -1 : 1;\n      const newAbosluteOffset = sign * scrollOffset.value + (location === 'prev' ? -1 : 1) * containerSize.value;\n      scrollOffset.value = sign * clamp(newAbosluteOffset, 0, contentSize.value - containerSize.value);\n    }\n    const contentStyles = computed(() => {\n      const scrollAmount = scrollOffset.value <= 0 ? bias(-scrollOffset.value) : scrollOffset.value > contentSize.value - containerSize.value ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value) : -scrollOffset.value;\n      return {\n        transform: `translate${isHorizontal.value ? 'X' : 'Y'}(${scrollAmount}px)`,\n        transition: disableTransition.value ? 'none' : '',\n        willChange: disableTransition.value ? 'transform' : ''\n      };\n    });\n    const slotProps = computed(() => ({\n      next: group.next,\n      prev: group.prev,\n      select: group.select,\n      isSelected: group.isSelected\n    }));\n    const hasAffixes = computed(() => {\n      switch (props.showArrows) {\n        // Always show arrows on desktop & mobile\n        case 'always':\n          return true;\n        // Always show arrows on desktop\n\n        case 'desktop':\n          return !mobile.value;\n        // Show arrows on mobile when overflowing.\n        // This matches the default 2.2 behavior\n\n        case true:\n          return isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n        // Always show on mobile\n\n        case 'mobile':\n          return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n        // https://material.io/components/tabs#scrollable-tabs\n        // Always show arrows when\n        // overflowed on desktop\n\n        default:\n          return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);\n      }\n    });\n    const hasPrev = computed(() => {\n      return hasAffixes.value && scrollOffset.value > 0;\n    });\n    const hasNext = computed(() => {\n      if (!hasAffixes.value) return false; // Check one scroll ahead to know the width of right-most item\n\n      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value;\n    });\n    useRender(() => {\n      var _slots$prev, _slots$prev2, _slots$default, _slots$next, _slots$next2;\n      return _createVNode(props.tag, {\n        \"class\": ['v-slide-group', {\n          'v-slide-group--vertical': !isHorizontal.value,\n          'v-slide-group--has-affixes': hasAffixes.value,\n          'v-slide-group--is-overflowing': isOverflowing.value\n        }],\n        \"tabindex\": isFocused.value || group.selected.value.length ? -1 : 0,\n        \"onFocus\": onFocus\n      }, {\n        default: () => [hasAffixes.value && _createVNode(\"div\", {\n          \"key\": \"prev\",\n          \"class\": ['v-slide-group__prev', {\n            'v-slide-group__prev--disabled': !hasPrev.value\n          }],\n          \"onClick\": () => scrollTo('prev')\n        }, [(_slots$prev = (_slots$prev2 = slots.prev) == null ? void 0 : _slots$prev2.call(slots, slotProps.value)) != null ? _slots$prev : _createVNode(VFadeTransition, null, {\n          default: () => [_createVNode(VIcon, {\n            \"icon\": props.prevIcon\n          }, null)]\n        })]), _createVNode(\"div\", {\n          \"key\": \"container\",\n          \"ref\": containerRef,\n          \"class\": \"v-slide-group__container\",\n          \"onScroll\": onScroll\n        }, [_createVNode(\"div\", {\n          \"ref\": contentRef,\n          \"class\": \"v-slide-group__content\",\n          \"style\": contentStyles.value,\n          \"onTouchstartPassive\": onTouchstart,\n          \"onTouchmovePassive\": onTouchmove,\n          \"onTouchendPassive\": onTouchend,\n          \"onFocusin\": onFocusin,\n          \"onFocusout\": onFocusout,\n          \"onKeydown\": onKeydown\n        }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, slotProps.value)])]), hasAffixes.value && _createVNode(\"div\", {\n          \"key\": \"next\",\n          \"class\": ['v-slide-group__next', {\n            'v-slide-group__next--disabled': !hasNext.value\n          }],\n          \"onClick\": () => scrollTo('next')\n        }, [(_slots$next = (_slots$next2 = slots.next) == null ? void 0 : _slots$next2.call(slots, slotProps.value)) != null ? _slots$next : _createVNode(VFadeTransition, null, {\n          default: () => [_createVNode(VIcon, {\n            \"icon\": props.nextIcon\n          }, null)]\n        })])]\n      });\n    });\n    return {\n      selected: group.selected,\n      scrollTo,\n      scrollOffset,\n      focus\n    };\n  }\n});","map":{"version":3,"mappings":"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","names":["VFadeTransition","VIcon","IconValue","makeGroupProps","useGroup","makeTagProps","useDisplay","useResizeObserver","useRtl","bias","calculateCenteredOffset","calculateUpdatedOffset","clamp","defineComponent","IN_BROWSER","useRender","computed","ref","watch","VSlideGroupSymbol","Symbol","for","VSlideGroup","name","props","centerActive","Boolean","direction","type","String","default","symbol","nextIcon","prevIcon","showArrows","validator","v","includes","selectedClass","emits","value","setup","slots","isRtl","mobile","group","isOverflowing","scrollOffset","containerSize","contentSize","isHorizontal","resizeRef","containerRef","contentRect","containerRect","contentRef","firstSelectedIndex","selected","length","items","findIndex","item","id","lastSelectedIndex","frame","cancelAnimationFrame","requestAnimationFrame","sizeProperty","selectedElement","children","currentScrollOffset","disableTransition","startTouch","startOffset","onTouchstart","e","touches","onTouchmove","onTouchend","maxScrollOffset","onScroll","scrollLeft","isFocused","onFocusin","el","composedPath","onFocusout","onFocus","relatedTarget","_contentRef$value","contains","focus","onKeydown","key","location","querySelector","focusable","querySelectorAll","filter","hasAttribute","_contentRef$value$que","nextElementSibling","_contentRef$value$que2","previousElementSibling","firstElementChild","lastElementChild","scrollTo","sign","newAbosluteOffset","contentStyles","scrollAmount","transform","transition","willChange","slotProps","next","prev","select","isSelected","hasAffixes","Math","abs","hasPrev","hasNext","onClick","_slots$prev2","_slots$default","_slots$next2"],"sources":["../../../src/components/VSlideGroup/VSlideGroup.tsx"],"sourcesContent":["// Styles\nimport './VSlideGroup.sass'\n\n// Components\nimport { VFadeTransition } from '@/components/transitions'\nimport { VIcon } from '@/components/VIcon'\n\n// Composables\nimport { IconValue } from '@/composables/icons'\nimport { makeGroupProps, useGroup } from '@/composables/group'\nimport { makeTagProps } from '@/composables/tag'\nimport { useDisplay } from '@/composables'\nimport { useResizeObserver } from '@/composables/resizeObserver'\nimport { useRtl } from '@/composables/rtl'\n\n// Utilities\nimport { bias, calculateCenteredOffset, calculateUpdatedOffset } from './helpers'\nimport { clamp, defineComponent, IN_BROWSER, useRender } from '@/util'\nimport { computed, ref, watch } from 'vue'\n\n// Types\nimport type { GroupProvide } from '@/composables/group'\nimport type { InjectionKey } from 'vue'\n\nexport const VSlideGroupSymbol: InjectionKey<GroupProvide> = Symbol.for('vuetify:v-slide-group')\n\nexport const VSlideGroup = defineComponent({\n  name: 'VSlideGroup',\n\n  props: {\n    centerActive: Boolean,\n    direction: {\n      type: String,\n      default: 'horizontal',\n    },\n    symbol: {\n      type: null,\n      default: VSlideGroupSymbol,\n    },\n    nextIcon: {\n      type: IconValue,\n      default: '$next',\n    },\n    prevIcon: {\n      type: IconValue,\n      default: '$prev',\n    },\n    showArrows: {\n      type: [Boolean, String],\n      validator: (v: any) => (\n        typeof v === 'boolean' || [\n          'always',\n          'desktop',\n          'mobile',\n        ].includes(v)\n      ),\n    },\n\n    ...makeTagProps(),\n    ...makeGroupProps({\n      selectedClass: 'v-slide-group-item--active',\n    }),\n  },\n\n  emits: {\n    'update:modelValue': (value: any) => true,\n  },\n\n  setup (props, { slots }) {\n    const { isRtl } = useRtl()\n    const { mobile } = useDisplay()\n    const group = useGroup(props, props.symbol)\n    const isOverflowing = ref(false)\n    const scrollOffset = ref(0)\n    const containerSize = ref(0)\n    const contentSize = ref(0)\n    const isHorizontal = computed(() => props.direction === 'horizontal')\n\n    const { resizeRef: containerRef, contentRect: containerRect } = useResizeObserver()\n    const { resizeRef: contentRef, contentRect } = useResizeObserver()\n\n    const firstSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1\n\n      return group.items.value.findIndex(item => item.id === group.selected.value[0])\n    })\n\n    const lastSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1\n\n      return group.items.value.findIndex(item => item.id === group.selected.value[group.selected.value.length - 1])\n    })\n\n    if (IN_BROWSER) {\n      let frame = -1\n      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {\n        cancelAnimationFrame(frame)\n        frame = requestAnimationFrame(() => {\n          if (containerRect.value && contentRect.value) {\n            const sizeProperty = isHorizontal.value ? 'width' : 'height'\n\n            containerSize.value = containerRect.value[sizeProperty]\n            contentSize.value = contentRect.value[sizeProperty]\n\n            isOverflowing.value = containerSize.value + 1 < contentSize.value\n          }\n\n          if (firstSelectedIndex.value >= 0 && contentRef.value) {\n            // TODO: Is this too naive? Should we store element references in group composable?\n            const selectedElement = contentRef.value.children[lastSelectedIndex.value] as HTMLElement\n\n            if (firstSelectedIndex.value === 0 || !isOverflowing.value) {\n              scrollOffset.value = 0\n            } else if (props.centerActive) {\n              scrollOffset.value = calculateCenteredOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                isHorizontal: isHorizontal.value,\n              })\n            } else if (isOverflowing.value) {\n              scrollOffset.value = calculateUpdatedOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                currentScrollOffset: scrollOffset.value,\n                isHorizontal: isHorizontal.value,\n              })\n            }\n          }\n        })\n      })\n    }\n\n    const disableTransition = ref(false)\n\n    let startTouch = 0\n    let startOffset = 0\n\n    function onTouchstart (e: TouchEvent) {\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY'\n      startOffset = scrollOffset.value\n      startTouch = e.touches[0][sizeProperty]\n      disableTransition.value = true\n    }\n\n    function onTouchmove (e: TouchEvent) {\n      if (!isOverflowing.value) return\n\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY'\n      scrollOffset.value = startOffset + startTouch - e.touches[0][sizeProperty]\n    }\n\n    function onTouchend (e: TouchEvent) {\n      const maxScrollOffset = contentSize.value - containerSize.value\n\n      if (isRtl.value) {\n        if (scrollOffset.value > 0 || !isOverflowing.value) {\n          scrollOffset.value = 0\n        } else if (scrollOffset.value <= -maxScrollOffset) {\n          scrollOffset.value = -maxScrollOffset\n        }\n      } else {\n        if (scrollOffset.value < 0 || !isOverflowing.value) {\n          scrollOffset.value = 0\n        } else if (scrollOffset.value >= maxScrollOffset) {\n          scrollOffset.value = maxScrollOffset\n        }\n      }\n\n      disableTransition.value = false\n    }\n\n    function onScroll () {\n      containerRef.value && (containerRef.value.scrollLeft = 0)\n    }\n\n    const isFocused = ref(false)\n    function onFocusin (e: FocusEvent) {\n      isFocused.value = true\n\n      if (!isOverflowing.value || !contentRef.value) return\n\n      // Focused element is likely to be the root of an item, so a\n      // breadth-first search will probably find it in the first iteration\n      for (const el of e.composedPath()) {\n        for (const item of contentRef.value.children) {\n          if (item === el) {\n            scrollOffset.value = calculateUpdatedOffset({\n              selectedElement: item as HTMLElement,\n              containerSize: containerSize.value,\n              contentSize: contentSize.value,\n              isRtl: isRtl.value,\n              currentScrollOffset: scrollOffset.value,\n              isHorizontal: isHorizontal.value,\n            })\n            return\n          }\n        }\n      }\n    }\n\n    function onFocusout (e: FocusEvent) {\n      isFocused.value = false\n    }\n\n    function onFocus (e: FocusEvent) {\n      if (\n        !isFocused.value &&\n        !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget as Node))\n      ) focus()\n    }\n\n    function onKeydown (e: KeyboardEvent) {\n      if (!contentRef.value) return\n\n      if (e.key === (isHorizontal.value ? 'ArrowRight' : 'ArrowDown')) {\n        focus('next')\n      } else if (e.key === (isHorizontal.value ? 'ArrowLeft' : 'ArrowUp')) {\n        focus('prev')\n      } else if (e.key === 'Home') {\n        focus('first')\n      } else if (e.key === 'End') {\n        focus('last')\n      }\n    }\n\n    function focus (location?: 'next' | 'prev' | 'first' | 'last') {\n      if (!contentRef.value) return\n\n      if (!location) {\n        contentRef.value.querySelector('[tabindex]')\n        const focusable = [...contentRef.value.querySelectorAll(\n          'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n        )].filter(el => !el.hasAttribute('disabled')) as HTMLElement[]\n        focusable[0]?.focus()\n      } else if (location === 'next') {\n        const el = contentRef.value.querySelector(':focus')?.nextElementSibling as HTMLElement | undefined\n        if (el) el.focus()\n        else focus('first')\n      } else if (location === 'prev') {\n        const el = contentRef.value.querySelector(':focus')?.previousElementSibling as HTMLElement | undefined\n        if (el) el.focus()\n        else focus('last')\n      } else if (location === 'first') {\n        (contentRef.value.firstElementChild as HTMLElement)?.focus()\n      } else if (location === 'last') {\n        (contentRef.value.lastElementChild as HTMLElement)?.focus()\n      }\n    }\n\n    function scrollTo (location: 'prev' | 'next') {\n      const sign = isRtl.value ? -1 : 1\n      const newAbosluteOffset = sign * scrollOffset.value +\n        (location === 'prev' ? -1 : 1) * containerSize.value\n\n      scrollOffset.value = sign * clamp(newAbosluteOffset, 0, contentSize.value - containerSize.value)\n    }\n\n    const contentStyles = computed(() => {\n      const scrollAmount = scrollOffset.value <= 0\n        ? bias(-scrollOffset.value)\n        : scrollOffset.value > contentSize.value - containerSize.value\n          ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value)\n          : -scrollOffset.value\n\n      return {\n        transform: `translate${isHorizontal.value ? 'X' : 'Y'}(${scrollAmount}px)`,\n        transition: disableTransition.value ? 'none' : '',\n        willChange: disableTransition.value ? 'transform' : '',\n      }\n    })\n\n    const slotProps = computed(() => ({\n      next: group.next,\n      prev: group.prev,\n      select: group.select,\n      isSelected: group.isSelected,\n    }))\n\n    const hasAffixes = computed(() => {\n      switch (props.showArrows) {\n        // Always show arrows on desktop & mobile\n        case 'always': return true\n\n        // Always show arrows on desktop\n        case 'desktop': return !mobile.value\n\n        // Show arrows on mobile when overflowing.\n        // This matches the default 2.2 behavior\n        case true: return isOverflowing.value || Math.abs(scrollOffset.value) > 0\n\n        // Always show on mobile\n        case 'mobile': return (\n          mobile.value ||\n          (isOverflowing.value || Math.abs(scrollOffset.value) > 0)\n        )\n\n        // https://material.io/components/tabs#scrollable-tabs\n        // Always show arrows when\n        // overflowed on desktop\n        default: return (\n          !mobile.value &&\n          (isOverflowing.value || Math.abs(scrollOffset.value) > 0)\n        )\n      }\n    })\n\n    const hasPrev = computed(() => {\n      return hasAffixes.value && scrollOffset.value > 0\n    })\n\n    const hasNext = computed(() => {\n      if (!hasAffixes.value) return false\n\n      // Check one scroll ahead to know the width of right-most item\n      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value\n    })\n\n    useRender(() => (\n      <props.tag\n        class={[\n          'v-slide-group',\n          {\n            'v-slide-group--vertical': !isHorizontal.value,\n            'v-slide-group--has-affixes': hasAffixes.value,\n            'v-slide-group--is-overflowing': isOverflowing.value,\n          },\n        ]}\n        tabindex={ (isFocused.value || group.selected.value.length) ? -1 : 0 }\n        onFocus={ onFocus }\n      >\n        { hasAffixes.value && (\n          <div\n            key=\"prev\"\n            class={[\n              'v-slide-group__prev',\n              { 'v-slide-group__prev--disabled': !hasPrev.value },\n            ]}\n            onClick={ () => scrollTo('prev') }\n          >\n            { slots.prev?.(slotProps.value) ?? (\n              <VFadeTransition>\n                <VIcon icon={ props.prevIcon }></VIcon>\n              </VFadeTransition>\n            ) }\n          </div>\n        ) }\n\n        <div\n          key=\"container\"\n          ref={ containerRef }\n          class=\"v-slide-group__container\"\n          onScroll={ onScroll }\n        >\n          <div\n            ref={ contentRef }\n            class=\"v-slide-group__content\"\n            style={ contentStyles.value }\n            onTouchstartPassive={ onTouchstart }\n            onTouchmovePassive={ onTouchmove }\n            onTouchendPassive={ onTouchend }\n            onFocusin={ onFocusin }\n            onFocusout={ onFocusout }\n            onKeydown={ onKeydown }\n          >\n            { slots.default?.(slotProps.value) }\n          </div>\n        </div>\n\n        { hasAffixes.value && (\n          <div\n            key=\"next\"\n            class={[\n              'v-slide-group__next',\n              { 'v-slide-group__next--disabled': !hasNext.value },\n            ]}\n            onClick={ () => scrollTo('next') }\n          >\n            { slots.next?.(slotProps.value) ?? (\n              <VFadeTransition>\n                <VIcon icon={ props.nextIcon }></VIcon>\n              </VFadeTransition>\n            ) }\n          </div>\n        ) }\n      </props.tag>\n    ))\n\n    return {\n      selected: group.selected,\n      scrollTo,\n      scrollOffset,\n      focus,\n    }\n  },\n})\n\nexport type VSlideGroup = InstanceType<typeof VSlideGroup>\n"]},"metadata":{},"sourceType":"module"}