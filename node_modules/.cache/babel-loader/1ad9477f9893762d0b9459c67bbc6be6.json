{"ast":null,"code":"import \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\n// Utilities\nimport { computed, effectScope, nextTick, onScopeDispose, ref, watch, watchEffect } from 'vue';\nimport { clamp, consoleError, convertToUnit, destructComputed, flipAlign, flipCorner, flipSide, getAxis, getScrollParents, IN_BROWSER, isFixedPosition, nullifyTransforms, parseAnchor, propsFactory } from \"../../util/index.mjs\";\nimport { Box, getOverflow } from \"../../util/box.mjs\";\nimport { anchorToPoint, getOffset } from \"./util/point.mjs\"; // Types\n\nconst locationStrategies = {\n  static: staticLocationStrategy,\n  // specific viewport position, usually centered\n  connected: connectedLocationStrategy // connected to a certain element\n};\nexport const makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function],\n    default: 'static',\n    validator: val => typeof val === 'function' || val in locationStrategies\n  },\n  location: {\n    type: String,\n    default: 'bottom'\n  },\n  origin: {\n    type: String,\n    default: 'auto'\n  },\n  offset: [Number, String, Array]\n});\nexport function useLocationStrategies(props, data) {\n  const contentStyles = ref({});\n  const updateLocation = ref();\n  let scope;\n  watchEffect(async () => {\n    var _scope;\n    (_scope = scope) == null ? void 0 : _scope.stop();\n    updateLocation.value = undefined;\n    if (!(IN_BROWSER && data.isActive.value && props.locationStrategy)) return;\n    scope = effectScope();\n    await nextTick();\n    scope.run(() => {\n      if (typeof props.locationStrategy === 'function') {\n        var _props$locationStrate;\n        updateLocation.value = (_props$locationStrate = props.locationStrategy(data, props, contentStyles)) == null ? void 0 : _props$locationStrate.updateLocation;\n      } else {\n        var _locationStrategies$p;\n        updateLocation.value = (_locationStrategies$p = locationStrategies[props.locationStrategy](data, props, contentStyles)) == null ? void 0 : _locationStrategies$p.updateLocation;\n      }\n    });\n  });\n  IN_BROWSER && window.addEventListener('resize', onResize, {\n    passive: true\n  });\n  onScopeDispose(() => {\n    var _scope2;\n    IN_BROWSER && window.removeEventListener('resize', onResize);\n    updateLocation.value = undefined;\n    (_scope2 = scope) == null ? void 0 : _scope2.stop();\n  });\n  function onResize(e) {\n    var _updateLocation$value;\n    (_updateLocation$value = updateLocation.value) == null ? void 0 : _updateLocation$value.call(updateLocation, e);\n  }\n  return {\n    contentStyles,\n    updateLocation\n  };\n}\nfunction staticLocationStrategy() {// TODO\n}\n/** Get size of element ignoring max-width/max-height */\n\nfunction getIntrinsicSize(el) {\n  // const scrollables = new Map<Element, [number, number]>()\n  // el.querySelectorAll('*').forEach(el => {\n  //   const x = el.scrollLeft\n  //   const y = el.scrollTop\n  //   if (x || y) {\n  //     scrollables.set(el, [x, y])\n  //   }\n  // })\n  // const initialMaxWidth = el.style.maxWidth\n  // const initialMaxHeight = el.style.maxHeight\n  // el.style.removeProperty('max-width')\n  // el.style.removeProperty('max-height')\n\n  /* eslint-disable-next-line sonarjs/prefer-immediate-return */\n  const contentBox = nullifyTransforms(el);\n  contentBox.x -= parseFloat(el.style.left || 0);\n  contentBox.y -= parseFloat(el.style.top || 0); // el.style.maxWidth = initialMaxWidth\n  // el.style.maxHeight = initialMaxHeight\n  // scrollables.forEach((position, el) => {\n  //   el.scrollTo(...position)\n  // })\n\n  return contentBox;\n}\nfunction connectedLocationStrategy(data, props, contentStyles) {\n  const activatorFixed = isFixedPosition(data.activatorEl.value);\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: 'fixed'\n    });\n  }\n  const {\n    preferredAnchor,\n    preferredOrigin\n  } = destructComputed(() => {\n    const parsedAnchor = parseAnchor(props.location, data.isRtl.value);\n    const parsedOrigin = props.origin === 'overlap' ? parsedAnchor : props.origin === 'auto' ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value); // Some combinations of props may produce an invalid origin\n\n    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {\n      return {\n        preferredAnchor: flipCorner(parsedAnchor),\n        preferredOrigin: flipCorner(parsedOrigin)\n      };\n    } else {\n      return {\n        preferredAnchor: parsedAnchor,\n        preferredOrigin: parsedOrigin\n      };\n    }\n  });\n  const [minWidth, minHeight, maxWidth, maxHeight] = ['minWidth', 'minHeight', 'maxWidth', 'maxHeight'].map(key => {\n    return computed(() => {\n      const val = parseFloat(props[key]);\n      return isNaN(val) ? Infinity : val;\n    });\n  });\n  const offset = computed(() => {\n    if (Array.isArray(props.offset)) {\n      return props.offset;\n    }\n    if (typeof props.offset === 'string') {\n      const offset = props.offset.split(' ').map(parseFloat);\n      if (offset.length < 2) offset.push(0);\n      return offset;\n    }\n    return typeof props.offset === 'number' ? [props.offset, 0] : [0, 0];\n  });\n  let observe = false;\n  if (IN_BROWSER) {\n    const observer = new ResizeObserver(() => {\n      if (observe) updateLocation();\n    });\n    observer.observe(data.activatorEl.value);\n    observer.observe(data.contentEl.value);\n    onScopeDispose(() => {\n      observer.disconnect();\n    });\n  } // eslint-disable-next-line max-statements\n\n  function updateLocation() {\n    observe = false;\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => observe = true);\n    });\n    const targetBox = data.activatorEl.value.getBoundingClientRect();\n    const contentBox = getIntrinsicSize(data.contentEl.value);\n    const scrollParents = getScrollParents(data.contentEl.value);\n    const viewportMargin = 12;\n    if (!scrollParents.length) {\n      scrollParents.push(document.documentElement);\n      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {\n        contentBox.x += parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0);\n        contentBox.y += parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0);\n      }\n    }\n    const viewport = scrollParents.reduce((box, el) => {\n      const rect = el.getBoundingClientRect();\n      const scrollBox = new Box({\n        x: el === document.documentElement ? 0 : rect.x,\n        y: el === document.documentElement ? 0 : rect.y,\n        width: el.clientWidth,\n        height: el.clientHeight\n      });\n      if (box) {\n        return new Box({\n          x: Math.max(box.left, scrollBox.left),\n          y: Math.max(box.top, scrollBox.top),\n          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),\n          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)\n        });\n      }\n      return scrollBox;\n    }, undefined);\n    viewport.x += viewportMargin;\n    viewport.y += viewportMargin;\n    viewport.width -= viewportMargin * 2;\n    viewport.height -= viewportMargin * 2;\n    let placement = {\n      anchor: preferredAnchor.value,\n      origin: preferredOrigin.value\n    };\n    function checkOverflow(_placement) {\n      const box = new Box(contentBox);\n      const targetPoint = anchorToPoint(_placement.anchor, targetBox);\n      const contentPoint = anchorToPoint(_placement.origin, box);\n      let {\n        x,\n        y\n      } = getOffset(targetPoint, contentPoint);\n      switch (_placement.anchor.side) {\n        case 'top':\n          y -= offset.value[0];\n          break;\n        case 'bottom':\n          y += offset.value[0];\n          break;\n        case 'left':\n          x -= offset.value[0];\n          break;\n        case 'right':\n          x += offset.value[0];\n          break;\n      }\n      switch (_placement.anchor.align) {\n        case 'top':\n          y -= offset.value[1];\n          break;\n        case 'bottom':\n          y += offset.value[1];\n          break;\n        case 'left':\n          x -= offset.value[1];\n          break;\n        case 'right':\n          x += offset.value[1];\n          break;\n      }\n      box.x += x;\n      box.y += y;\n      box.width = Math.min(box.width, maxWidth.value);\n      box.height = Math.min(box.height, maxHeight.value);\n      const overflows = getOverflow(box, viewport);\n      return {\n        overflows,\n        x,\n        y\n      };\n    }\n    let x = 0;\n    let y = 0;\n    const available = {\n      x: 0,\n      y: 0\n    };\n    const flipped = {\n      x: false,\n      y: false\n    };\n    let resets = -1;\n    while (true) {\n      if (resets++ > 10) {\n        consoleError('Infinite loop detected in connectedLocationStrategy');\n        break;\n      }\n      const {\n        x: _x,\n        y: _y,\n        overflows\n      } = checkOverflow(placement);\n      x += _x;\n      y += _y;\n      contentBox.x += _x;\n      contentBox.y += _y; // flip\n\n      {\n        const axis = getAxis(placement.anchor);\n        const hasOverflowX = overflows.x.before || overflows.x.after;\n        const hasOverflowY = overflows.y.before || overflows.y.after;\n        let reset = false;\n        ['x', 'y'].forEach(key => {\n          if (key === 'x' && hasOverflowX && !flipped.x || key === 'y' && hasOverflowY && !flipped.y) {\n            const newPlacement = {\n              anchor: {\n                ...placement.anchor\n              },\n              origin: {\n                ...placement.origin\n              }\n            };\n            const flip = key === 'x' ? axis === 'y' ? flipAlign : flipSide : axis === 'y' ? flipSide : flipAlign;\n            newPlacement.anchor = flip(newPlacement.anchor);\n            newPlacement.origin = flip(newPlacement.origin);\n            const {\n              overflows: newOverflows\n            } = checkOverflow(newPlacement);\n            if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {\n              placement = newPlacement;\n              reset = flipped[key] = true;\n            }\n          }\n        });\n        if (reset) continue;\n      } // shift\n\n      if (overflows.x.before) {\n        x += overflows.x.before;\n        contentBox.x += overflows.x.before;\n      }\n      if (overflows.x.after) {\n        x -= overflows.x.after;\n        contentBox.x -= overflows.x.after;\n      }\n      if (overflows.y.before) {\n        y += overflows.y.before;\n        contentBox.y += overflows.y.before;\n      }\n      if (overflows.y.after) {\n        y -= overflows.y.after;\n        contentBox.y -= overflows.y.after;\n      } // size\n\n      {\n        const overflows = getOverflow(contentBox, viewport);\n        available.x = viewport.width - overflows.x.before - overflows.x.after;\n        available.y = viewport.height - overflows.y.before - overflows.y.after;\n        x += overflows.x.before;\n        contentBox.x += overflows.x.before;\n        y += overflows.y.before;\n        contentBox.y += overflows.y.before;\n      }\n      break;\n    }\n    const axis = getAxis(placement.anchor);\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': `${placement.anchor.side} ${placement.anchor.align}`,\n      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,\n      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,\n      top: convertToUnit(pixelRound(y)),\n      left: convertToUnit(pixelRound(x)),\n      minWidth: convertToUnit(axis === 'y' ? Math.min(minWidth.value, targetBox.width) : minWidth.value),\n      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),\n      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))\n    });\n  }\n  watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight], () => updateLocation(), {\n    immediate: !activatorFixed\n  });\n  if (activatorFixed) nextTick(() => updateLocation());\n  requestAnimationFrame(() => {\n    if (contentStyles.value.maxHeight) updateLocation();\n  });\n  return {\n    updateLocation\n  };\n}\nfunction pixelRound(val) {\n  return Math.round(val * devicePixelRatio) / devicePixelRatio;\n}\nfunction pixelCeil(val) {\n  return Math.ceil(val * devicePixelRatio) / devicePixelRatio;\n}","map":{"version":3,"mappings":";;;AAAA;AACA,SAASA,QAAT,EAAmBC,WAAnB,EAAgCC,QAAhC,EAA0CC,cAA1C,EAA0DC,GAA1D,EAA+DC,KAA/D,EAAsEC,WAAtE,QAAyF,KAAzF;SAEEC,K,EACAC,Y,EACAC,a,EACAC,gB,EACAC,S,EACAC,U,EACAC,Q,EACAC,O,EACAC,gB,EACAC,U,EACAC,e,EACAC,iB,EACAC,W,EACAC,Y;SAEOC,G,EAAKC,W;SACLC,a,EAAeC,S,4BAExB;;AAWA,MAAMC,kBAAkB,GAAG;EACzBC,MAAM,EAAEC,sBADiB;EACO;EAChCC,SAAS,EAAEC,yBAFc,CAEa;AAFb,CAA3B;AAsBA,OAAO,MAAMC,yBAAyB,GAAGV,YAAY,CAAC;EACpDW,gBAAgB,EAAE;IAChBC,IAAI,EAAE,CAACC,MAAD,EAASC,QAAT,CADU;IAEhBC,OAAO,EAAE,QAFO;IAGhBC,SAAS,EAAGC,GAAD,IAAc,OAAOA,GAAP,KAAe,UAAf,IAA6BA,GAAG,IAAIZ;EAH7C,CADkC;EAMpDa,QAAQ,EAAE;IACRN,IAAI,EAAEC,MADE;IAERE,OAAO,EAAE;EAFD,CAN0C;EAUpDI,MAAM,EAAE;IACNP,IAAI,EAAEC,MADA;IAENE,OAAO,EAAE;EAFH,CAV4C;EAcpDK,MAAM,EAAE,CAACC,MAAD,EAASR,MAAT,EAAiBS,KAAjB;AAd4C,CAAD,CAA9C;AAiBP,OAAO,SAASC,qBAATA,CACLC,KADK,EAELC,IAFK,EAGL;EACA,MAAMC,aAAa,GAAG1C,GAAG,CAAC,EAAD,CAAzB;EACA,MAAM2C,cAAc,GAAG3C,GAAG,EAA1B;EAEA,IAAI4C,KAAJ;EACA1C,WAAW,CAAC,YAAY;IAAA;IACtB,eAAK,SAAL,mBAAO2C,IAAP;IACAF,cAAc,CAACG,KAAf,GAAuBC,SAAvB;IAEA,IAAI,EAAEnC,UAAU,IAAI6B,IAAI,CAACO,QAAL,CAAcF,KAA5B,IAAqCN,KAAK,CAACb,gBAA7C,CAAJ,EAAoE;IAEpEiB,KAAK,GAAG/C,WAAW,EAAnB;IACA,MAAMC,QAAQ,EAAd;IACA8C,KAAK,CAACK,GAAN,CAAU,MAAM;MACd,IAAI,OAAOT,KAAK,CAACb,gBAAb,KAAkC,UAAtC,EAAkD;QAAA;QAChDgB,cAAc,CAACG,KAAf,4BAAuBN,KAAK,CAACb,gBAAN,CAAuBc,IAAvB,EAA6BD,KAA7B,EAAoCE,aAApC,CAAvB,qBAAuBQ,sBAAoDP,cAA3E;MACD,CAFD,MAEO;QAAA;QACLA,cAAc,CAACG,KAAf,4BAAuBzB,kBAAkB,CAACmB,KAAK,CAACb,gBAAP,CAAlB,CAA2Cc,IAA3C,EAAiDD,KAAjD,EAAwDE,aAAxD,CAAvB,qBAAuBS,sBAAwER,cAA/F;MACD;IACF,CAND;EAOD,CAfU,CAAX;EAiBA/B,UAAU,IAAIwC,MAAM,CAACC,gBAAP,CAAwB,QAAxB,EAAkCC,QAAlC,EAA4C;IAAEC,OAAO,EAAE;EAAX,CAA5C,CAAd;EAEAxD,cAAc,CAAC,MAAM;IAAA;IACnBa,UAAU,IAAIwC,MAAM,CAACI,mBAAP,CAA2B,QAA3B,EAAqCF,QAArC,CAAd;IACAX,cAAc,CAACG,KAAf,GAAuBC,SAAvB;IACA,gBAAK,SAAL,oBAAOF,IAAP;EACD,CAJa,CAAd;EAMA,SAASS,QAATA,CAAmBG,CAAnB,EAA6B;IAAA;IAC3B,uCAAc,CAACX,KAAf,8DAAc,EAASW,CAAT,CAAd;EACD;EAED,OAAO;IACLf,aADK;IAELC;EAFK,CAAP;AAID;AAED,SAASpB,sBAATA,GAAmC,CACjC;AAAA;AAGF;;AACA,SAASmC,gBAATA,CAA2BC,EAA3B,EAA4C;EAC1C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;;EAEA;EACA,MAAMC,UAAU,GAAG9C,iBAAiB,CAAC6C,EAAD,CAApC;EAEAC,UAAU,CAACC,CAAX,IAAgBC,UAAU,CAACH,EAAE,CAACI,KAAH,CAASC,IAAT,IAAiB,CAAlB,CAA1B;EACAJ,UAAU,CAACK,CAAX,IAAgBH,UAAU,CAACH,EAAE,CAACI,KAAH,CAASG,GAAT,IAAgB,CAAjB,CAA1B,CAnB0C,CAqB1C;EACA;EACA;EACA;EACA;;EAEA,OAAON,UAAP;AACD;AAED,SAASnC,yBAATA,CAAoCgB,IAApC,EAAgED,KAAhE,EAAsFE,aAAtF,EAAkI;EAChI,MAAMyB,cAAc,GAAGtD,eAAe,CAAC4B,IAAI,CAAC2B,WAAL,CAAiBtB,KAAlB,CAAtC;EACA,IAAIqB,cAAJ,EAAoB;IAClBE,MAAM,CAACC,MAAP,CAAc5B,aAAa,CAACI,KAA5B,EAAmC;MACjCyB,QAAQ,EAAE;IADuB,CAAnC;EAGD;EAED,MAAM;IAAEC,eAAF;IAAmBC;EAAnB,IAAuCnE,gBAAgB,CAAC,MAAM;IAClE,MAAMoE,YAAY,GAAG3D,WAAW,CAACyB,KAAK,CAACN,QAAP,EAAiBO,IAAI,CAACkC,KAAL,CAAW7B,KAA5B,CAAhC;IACA,MAAM8B,YAAY,GAChBpC,KAAK,CAACL,MAAN,KAAiB,SAAjB,GAA6BuC,YAA7B,GACElC,KAAK,CAACL,MAAN,KAAiB,MAAjB,GAA0B1B,QAAQ,CAACiE,YAAD,CAAlC,GACA3D,WAAW,CAACyB,KAAK,CAACL,MAAP,EAAeM,IAAI,CAACkC,KAAL,CAAW7B,KAA1B,CAHf,CAFkE,CAOlE;;IACA,IAAI4B,YAAY,CAACG,IAAb,KAAsBD,YAAY,CAACC,IAAnC,IAA2CH,YAAY,CAACI,KAAb,KAAuBvE,SAAS,CAACqE,YAAD,CAAT,CAAwBE,KAA9F,EAAqG;MACnG,OAAO;QACLN,eAAe,EAAEhE,UAAU,CAACkE,YAAD,CADtB;QAELD,eAAe,EAAEjE,UAAU,CAACoE,YAAD;MAFtB,CAAP;IAID,CALD,MAKO;MACL,OAAO;QACLJ,eAAe,EAAEE,YADZ;QAELD,eAAe,EAAEG;MAFZ,CAAP;IAID;EACF,CAnB4D,CAA7D;EAqBA,MAAM,CAACG,QAAD,EAAWC,SAAX,EAAsBC,QAAtB,EAAgCC,SAAhC,IACH,CAAC,UAAD,EAAa,WAAb,EAA0B,UAA1B,EAAsC,WAAtC,CAAD,CAA8DC,GAA9D,CAAkEC,GAAG,IAAI;IACvE,OAAOxF,QAAQ,CAAC,MAAM;MACpB,MAAMqC,GAAG,GAAG6B,UAAU,CAACtB,KAAK,CAAC4C,GAAD,CAAN,CAAtB;MACA,OAAOC,KAAK,CAACpD,GAAD,CAAL,GAAaqD,QAAb,GAAwBrD,GAA/B;IACD,CAHc,CAAf;EAID,CALD,CADF;EAQA,MAAMG,MAAM,GAAGxC,QAAQ,CAAC,MAAM;IAC5B,IAAI0C,KAAK,CAACiD,OAAN,CAAc/C,KAAK,CAACJ,MAApB,CAAJ,EAAiC;MAC/B,OAAOI,KAAK,CAACJ,MAAb;IACD;IACD,IAAI,OAAOI,KAAK,CAACJ,MAAb,KAAwB,QAA5B,EAAsC;MACpC,MAAMA,MAAM,GAAGI,KAAK,CAACJ,MAAN,CAAaoD,KAAb,CAAmB,GAAnB,EAAwBL,GAAxB,CAA4BrB,UAA5B,CAAf;MACA,IAAI1B,MAAM,CAACqD,MAAP,GAAgB,CAApB,EAAuBrD,MAAM,CAACsD,IAAP,CAAY,CAAZ;MACvB,OAAOtD,MAAP;IACD;IACD,OAAO,OAAOI,KAAK,CAACJ,MAAb,KAAwB,QAAxB,GAAmC,CAACI,KAAK,CAACJ,MAAP,EAAe,CAAf,CAAnC,GAAuD,CAAC,CAAD,EAAI,CAAJ,CAA9D;EACD,CAVsB,CAAvB;EAYA,IAAIuD,OAAO,GAAG,KAAd;EACA,IAAI/E,UAAJ,EAAgB;IACd,MAAMgF,QAAQ,GAAG,IAAIC,cAAJ,CAAmB,MAAM;MACxC,IAAIF,OAAJ,EAAahD,cAAc;IAC5B,CAFgB,CAAjB;IAGAiD,QAAQ,CAACD,OAAT,CAAiBlD,IAAI,CAAC2B,WAAL,CAAiBtB,KAAlC;IACA8C,QAAQ,CAACD,OAAT,CAAiBlD,IAAI,CAACqD,SAAL,CAAehD,KAAhC;IAEA/C,cAAc,CAAC,MAAM;MACnB6F,QAAQ,CAACG,UAAT;IACD,CAFa,CAAd;EAGD,CA5D+H,CA8DhI;;EACA,SAASpD,cAATA,GAA2B;IACzBgD,OAAO,GAAG,KAAV;IACAK,qBAAqB,CAAC,MAAM;MAC1BA,qBAAqB,CAAC,MAAML,OAAO,GAAG,IAAjB,CAArB;IACD,CAFoB,CAArB;IAIA,MAAMM,SAAS,GAAGxD,IAAI,CAAC2B,WAAL,CAAiBtB,KAAjB,CAAwBoD,qBAAxB,EAAlB;IACA,MAAMtC,UAAU,GAAGF,gBAAgB,CAACjB,IAAI,CAACqD,SAAL,CAAehD,KAAhB,CAAnC;IACA,MAAMqD,aAAa,GAAGxF,gBAAgB,CAAC8B,IAAI,CAACqD,SAAL,CAAehD,KAAhB,CAAtC;IACA,MAAMsD,cAAc,GAAG,EAAvB;IAEA,IAAI,CAACD,aAAa,CAACV,MAAnB,EAA2B;MACzBU,aAAa,CAACT,IAAd,CAAmBW,QAAQ,CAACC,eAA5B;MACA,IAAI,EAAE7D,IAAI,CAACqD,SAAL,CAAehD,KAAf,CAAsBiB,KAAtB,CAA4BG,GAA5B,IAAmCzB,IAAI,CAACqD,SAAL,CAAehD,KAAf,CAAsBiB,KAAtB,CAA4BC,IAAjE,CAAJ,EAA4E;QAC1EJ,UAAU,CAACC,CAAX,IAAgBC,UAAU,CAACuC,QAAQ,CAACC,eAAT,CAAyBvC,KAAzB,CAA+BwC,gBAA/B,CAAgD,mBAAhD,KAAwE,CAAzE,CAA1B;QACA3C,UAAU,CAACK,CAAX,IAAgBH,UAAU,CAACuC,QAAQ,CAACC,eAAT,CAAyBvC,KAAzB,CAA+BwC,gBAA/B,CAAgD,mBAAhD,KAAwE,CAAzE,CAA1B;MACD;IACF;IAED,MAAMC,QAAQ,GAAGL,aAAa,CAACM,MAAd,CAA0B,CAACC,GAAD,EAAuB/C,EAAvB,KAA8B;MACvE,MAAMgD,IAAI,GAAGhD,EAAE,CAACuC,qBAAH,EAAb;MACA,MAAMU,SAAS,GAAG,IAAI3F,GAAJ,CAAQ;QACxB4C,CAAC,EAAEF,EAAE,KAAK0C,QAAQ,CAACC,eAAhB,GAAkC,CAAlC,GAAsCK,IAAI,CAAC9C,CADtB;QAExBI,CAAC,EAAEN,EAAE,KAAK0C,QAAQ,CAACC,eAAhB,GAAkC,CAAlC,GAAsCK,IAAI,CAAC1C,CAFtB;QAGxB4C,KAAK,EAAElD,EAAE,CAACmD,WAHc;QAIxBC,MAAM,EAAEpD,EAAE,CAACqD;MAJa,CAAR,CAAlB;MAOA,IAAIN,GAAJ,EAAS;QACP,OAAO,IAAIzF,GAAJ,CAAQ;UACb4C,CAAC,EAAEoD,IAAI,CAACC,GAAL,CAASR,GAAG,CAAC1C,IAAb,EAAmB4C,SAAS,CAAC5C,IAA7B,CADU;UAEbC,CAAC,EAAEgD,IAAI,CAACC,GAAL,CAASR,GAAG,CAACxC,GAAb,EAAkB0C,SAAS,CAAC1C,GAA5B,CAFU;UAGb2C,KAAK,EAAEI,IAAI,CAACE,GAAL,CAAST,GAAG,CAACU,KAAb,EAAoBR,SAAS,CAACQ,KAA9B,IAAuCH,IAAI,CAACC,GAAL,CAASR,GAAG,CAAC1C,IAAb,EAAmB4C,SAAS,CAAC5C,IAA7B,CAHjC;UAIb+C,MAAM,EAAEE,IAAI,CAACE,GAAL,CAAST,GAAG,CAACW,MAAb,EAAqBT,SAAS,CAACS,MAA/B,IAAyCJ,IAAI,CAACC,GAAL,CAASR,GAAG,CAACxC,GAAb,EAAkB0C,SAAS,CAAC1C,GAA5B;QAJpC,CAAR,CAAP;MAMD;MACD,OAAO0C,SAAP;IACD,CAlBgB,EAkBd7D,SAlBc,CAAjB;IAmBAyD,QAAQ,CAAC3C,CAAT,IAAcuC,cAAd;IACAI,QAAQ,CAACvC,CAAT,IAAcmC,cAAd;IACAI,QAAQ,CAACK,KAAT,IAAkBT,cAAc,GAAG,CAAnC;IACAI,QAAQ,CAACO,MAAT,IAAmBX,cAAc,GAAG,CAApC;IAEA,IAAIkB,SAAS,GAAG;MACdC,MAAM,EAAE/C,eAAe,CAAC1B,KADV;MAEdX,MAAM,EAAEsC,eAAe,CAAC3B;IAFV,CAAhB;IAKA,SAAS0E,aAATA,CAAwBC,UAAxB,EAAsD;MACpD,MAAMf,GAAG,GAAG,IAAIzF,GAAJ,CAAQ2C,UAAR,CAAZ;MACA,MAAM8D,WAAW,GAAGvG,aAAa,CAACsG,UAAU,CAACF,MAAZ,EAAoBtB,SAApB,CAAjC;MACA,MAAM0B,YAAY,GAAGxG,aAAa,CAACsG,UAAU,CAACtF,MAAZ,EAAoBuE,GAApB,CAAlC;MAEA,IAAI;QAAE7C,CAAF;QAAKI;MAAL,IAAW7C,SAAS,CAACsG,WAAD,EAAcC,YAAd,CAAxB;MAEA,QAAQF,UAAU,CAACF,MAAX,CAAkB1C,IAA1B;QACE,KAAK,KAAL;UAAYZ,CAAC,IAAI7B,MAAM,CAACU,KAAP,CAAa,CAAb,CAAL;UAAsB;QAClC,KAAK,QAAL;UAAemB,CAAC,IAAI7B,MAAM,CAACU,KAAP,CAAa,CAAb,CAAL;UAAsB;QACrC,KAAK,MAAL;UAAae,CAAC,IAAIzB,MAAM,CAACU,KAAP,CAAa,CAAb,CAAL;UAAsB;QACnC,KAAK,OAAL;UAAce,CAAC,IAAIzB,MAAM,CAACU,KAAP,CAAa,CAAb,CAAL;UAAsB;MAJtC;MAOA,QAAQ2E,UAAU,CAACF,MAAX,CAAkBzC,KAA1B;QACE,KAAK,KAAL;UAAYb,CAAC,IAAI7B,MAAM,CAACU,KAAP,CAAa,CAAb,CAAL;UAAsB;QAClC,KAAK,QAAL;UAAemB,CAAC,IAAI7B,MAAM,CAACU,KAAP,CAAa,CAAb,CAAL;UAAsB;QACrC,KAAK,MAAL;UAAae,CAAC,IAAIzB,MAAM,CAACU,KAAP,CAAa,CAAb,CAAL;UAAsB;QACnC,KAAK,OAAL;UAAce,CAAC,IAAIzB,MAAM,CAACU,KAAP,CAAa,CAAb,CAAL;UAAsB;MAJtC;MAOA4D,GAAG,CAAC7C,CAAJ,IAASA,CAAT;MACA6C,GAAG,CAACzC,CAAJ,IAASA,CAAT;MAEAyC,GAAG,CAACG,KAAJ,GAAYI,IAAI,CAACE,GAAL,CAAST,GAAG,CAACG,KAAb,EAAoB5B,QAAQ,CAACnC,KAA7B,CAAZ;MACA4D,GAAG,CAACK,MAAJ,GAAaE,IAAI,CAACE,GAAL,CAAST,GAAG,CAACK,MAAb,EAAqB7B,SAAS,CAACpC,KAA/B,CAAb;MAEA,MAAM8E,SAAS,GAAG1G,WAAW,CAACwF,GAAD,EAAMF,QAAN,CAA7B;MAEA,OAAO;QAAEoB,SAAF;QAAa/D,CAAb;QAAgBI;MAAhB,CAAP;IACD;IAED,IAAIJ,CAAC,GAAG,CAAR;IAAW,IAAII,CAAC,GAAG,CAAR;IACX,MAAM4D,SAAS,GAAG;MAAEhE,CAAC,EAAE,CAAL;MAAQI,CAAC,EAAE;IAAX,CAAlB;IACA,MAAM6D,OAAO,GAAG;MAAEjE,CAAC,EAAE,KAAL;MAAYI,CAAC,EAAE;IAAf,CAAhB;IACA,IAAI8D,MAAM,GAAG,CAAC,CAAd;IACA,OAAO,IAAP,EAAa;MACX,IAAIA,MAAM,KAAK,EAAf,EAAmB;QACjB3H,YAAY,CAAC,qDAAD,CAAZ;QACA;MACD;MAED,MAAM;QAAEyD,CAAC,EAAEmE,EAAL;QAAS/D,CAAC,EAAEgE,EAAZ;QAAgBL;MAAhB,IAA8BJ,aAAa,CAACF,SAAD,CAAjD;MAEAzD,CAAC,IAAImE,EAAL;MACA/D,CAAC,IAAIgE,EAAL;MAEArE,UAAU,CAACC,CAAX,IAAgBmE,EAAhB;MACApE,UAAU,CAACK,CAAX,IAAgBgE,EAAhB,CAZW,CAcX;;MACA;QACE,MAAMC,IAAI,GAAGxH,OAAO,CAAC4G,SAAS,CAACC,MAAX,CAApB;QACA,MAAMY,YAAY,GAAGP,SAAS,CAAC/D,CAAV,CAAYuE,MAAZ,IAAsBR,SAAS,CAAC/D,CAAV,CAAYwE,KAAvD;QACA,MAAMC,YAAY,GAAGV,SAAS,CAAC3D,CAAV,CAAYmE,MAAZ,IAAsBR,SAAS,CAAC3D,CAAV,CAAYoE,KAAvD;QAEA,IAAIE,KAAK,GAAG,KAAZ;QACC,CAAC,GAAD,EAAM,GAAN,EAAWC,OAAX,CAAmBpD,GAAG,IAAI;UACzB,IACGA,GAAG,KAAK,GAAR,IAAe+C,YAAf,IAA+B,CAACL,OAAO,CAACjE,CAAzC,IACCuB,GAAG,KAAK,GAAR,IAAekD,YAAf,IAA+B,CAACR,OAAO,CAAC7D,CAF3C,EAGE;YACA,MAAMwE,YAAY,GAAG;cAAElB,MAAM,EAAE;gBAAE,GAAGD,SAAS,CAACC;cAAf,CAAV;cAAmCpF,MAAM,EAAE;gBAAE,GAAGmF,SAAS,CAACnF;cAAf;YAA3C,CAArB;YACA,MAAMuG,IAAI,GAAGtD,GAAG,KAAK,GAAR,GACT8C,IAAI,KAAK,GAAT,GAAe3H,SAAf,GAA2BE,QADlB,GAETyH,IAAI,KAAK,GAAT,GAAezH,QAAf,GAA0BF,SAF9B;YAGAkI,YAAY,CAAClB,MAAb,GAAsBmB,IAAI,CAACD,YAAY,CAAClB,MAAd,CAA1B;YACAkB,YAAY,CAACtG,MAAb,GAAsBuG,IAAI,CAACD,YAAY,CAACtG,MAAd,CAA1B;YACA,MAAM;cAAEyF,SAAS,EAAEe;YAAb,IAA8BnB,aAAa,CAACiB,YAAD,CAAjD;YACA,IACGE,YAAY,CAACvD,GAAD,CAAZ,CAAkBgD,MAAlB,IAA4BR,SAAS,CAACxC,GAAD,CAAT,CAAegD,MAA3C,IACCO,YAAY,CAACvD,GAAD,CAAZ,CAAkBiD,KAAlB,IAA2BT,SAAS,CAACxC,GAAD,CAAT,CAAeiD,KAD5C,IAECM,YAAY,CAACvD,GAAD,CAAZ,CAAkBgD,MAAlB,GAA2BO,YAAY,CAACvD,GAAD,CAAZ,CAAkBiD,KAA7C,GACC,CAACT,SAAS,CAACxC,GAAD,CAAT,CAAegD,MAAf,GAAwBR,SAAS,CAACxC,GAAD,CAAT,CAAeiD,KAAxC,IAAiD,CAJrD,EAKE;cACAf,SAAS,GAAGmB,YAAZ;cACAF,KAAK,GAAGT,OAAO,CAAC1C,GAAD,CAAP,GAAe,IAAvB;YACD;UACF;QACF,CAtBA;QAuBD,IAAImD,KAAJ,EAAW;MACZ,CA7CU,CA+CX;;MACA,IAAIX,SAAS,CAAC/D,CAAV,CAAYuE,MAAhB,EAAwB;QACtBvE,CAAC,IAAI+D,SAAS,CAAC/D,CAAV,CAAYuE,MAAjB;QACAxE,UAAU,CAACC,CAAX,IAAgB+D,SAAS,CAAC/D,CAAV,CAAYuE,MAA5B;MACD;MACD,IAAIR,SAAS,CAAC/D,CAAV,CAAYwE,KAAhB,EAAuB;QACrBxE,CAAC,IAAI+D,SAAS,CAAC/D,CAAV,CAAYwE,KAAjB;QACAzE,UAAU,CAACC,CAAX,IAAgB+D,SAAS,CAAC/D,CAAV,CAAYwE,KAA5B;MACD;MACD,IAAIT,SAAS,CAAC3D,CAAV,CAAYmE,MAAhB,EAAwB;QACtBnE,CAAC,IAAI2D,SAAS,CAAC3D,CAAV,CAAYmE,MAAjB;QACAxE,UAAU,CAACK,CAAX,IAAgB2D,SAAS,CAAC3D,CAAV,CAAYmE,MAA5B;MACD;MACD,IAAIR,SAAS,CAAC3D,CAAV,CAAYoE,KAAhB,EAAuB;QACrBpE,CAAC,IAAI2D,SAAS,CAAC3D,CAAV,CAAYoE,KAAjB;QACAzE,UAAU,CAACK,CAAX,IAAgB2D,SAAS,CAAC3D,CAAV,CAAYoE,KAA5B;MACD,CA/DU,CAiEX;;MACA;QACE,MAAMT,SAAS,GAAG1G,WAAW,CAAC0C,UAAD,EAAa4C,QAAb,CAA7B;QACAqB,SAAS,CAAChE,CAAV,GAAc2C,QAAQ,CAACK,KAAT,GAAiBe,SAAS,CAAC/D,CAAV,CAAYuE,MAA7B,GAAsCR,SAAS,CAAC/D,CAAV,CAAYwE,KAAhE;QACAR,SAAS,CAAC5D,CAAV,GAAcuC,QAAQ,CAACO,MAAT,GAAkBa,SAAS,CAAC3D,CAAV,CAAYmE,MAA9B,GAAuCR,SAAS,CAAC3D,CAAV,CAAYoE,KAAjE;QAEAxE,CAAC,IAAI+D,SAAS,CAAC/D,CAAV,CAAYuE,MAAjB;QACAxE,UAAU,CAACC,CAAX,IAAgB+D,SAAS,CAAC/D,CAAV,CAAYuE,MAA5B;QACAnE,CAAC,IAAI2D,SAAS,CAAC3D,CAAV,CAAYmE,MAAjB;QACAxE,UAAU,CAACK,CAAX,IAAgB2D,SAAS,CAAC3D,CAAV,CAAYmE,MAA5B;MACD;MAED;IACD;IAED,MAAMF,IAAI,GAAGxH,OAAO,CAAC4G,SAAS,CAACC,MAAX,CAApB;IAEAlD,MAAM,CAACC,MAAP,CAAc5B,aAAa,CAACI,KAA5B,EAAmC;MACjC,6BAA8B,GAAEwE,SAAS,CAACC,MAAV,CAAiB1C,IAAK,IAAGyC,SAAS,CAACC,MAAV,CAAiBzC,KAAM,EAD/C;MAEjC8D,eAAe,EAAG,GAAEtB,SAAS,CAACnF,MAAV,CAAiB0C,IAAK,IAAGyC,SAAS,CAACnF,MAAV,CAAiB2C,KAAM,EAFnC;MAGjC;MACAZ,GAAG,EAAE7D,aAAa,CAACwI,UAAU,CAAC5E,CAAD,CAAX,CAJe;MAKjCD,IAAI,EAAE3D,aAAa,CAACwI,UAAU,CAAChF,CAAD,CAAX,CALc;MAMjCkB,QAAQ,EAAE1E,aAAa,CAAC6H,IAAI,KAAK,GAAT,GAAejB,IAAI,CAACE,GAAL,CAASpC,QAAQ,CAACjC,KAAlB,EAAyBmD,SAAS,CAACY,KAAnC,CAAf,GAA2D9B,QAAQ,CAACjC,KAArE,CANU;MAOjCmC,QAAQ,EAAE5E,aAAa,CAACyI,SAAS,CAAC3I,KAAK,CAAC0H,SAAS,CAAChE,CAAX,EAAckB,QAAQ,CAACjC,KAAT,KAAmBwC,QAAnB,GAA8B,CAA9B,GAAkCP,QAAQ,CAACjC,KAAzD,EAAgEmC,QAAQ,CAACnC,KAAzE,CAAN,CAAV,CAPU;MAQjCoC,SAAS,EAAE7E,aAAa,CAACyI,SAAS,CAAC3I,KAAK,CAAC0H,SAAS,CAAC5D,CAAX,EAAce,SAAS,CAAClC,KAAV,KAAoBwC,QAApB,GAA+B,CAA/B,GAAmCN,SAAS,CAAClC,KAA3D,EAAkEoC,SAAS,CAACpC,KAA5E,CAAN,CAAV;IARS,CAAnC;EAUD;EAED7C,KAAK,CACH,MAAM,CACJuE,eAAe,CAAC1B,KADZ,EAEJ2B,eAAe,CAAC3B,KAFZ,EAGJN,KAAK,CAACJ,MAHF,EAIJI,KAAK,CAACuC,QAJF,EAKJvC,KAAK,CAACwC,SALF,EAMJxC,KAAK,CAACyC,QANF,EAOJzC,KAAK,CAAC0C,SAPF,CADH,EAUH,MAAMvC,cAAc,EAVjB,EAWH;IAAEoG,SAAS,EAAE,CAAC5E;EAAd,CAXG,CAAL;EAcA,IAAIA,cAAJ,EAAoBrE,QAAQ,CAAC,MAAM6C,cAAc,EAArB,CAAR;EACpBqD,qBAAqB,CAAC,MAAM;IAC1B,IAAItD,aAAa,CAACI,KAAd,CAAoBoC,SAAxB,EAAmCvC,cAAc;EAClD,CAFoB,CAArB;EAIA,OAAO;IAAEA;EAAF,CAAP;AACD;AAED,SAASkG,UAATA,CAAqB5G,GAArB,EAAkC;EAChC,OAAOgF,IAAI,CAAC+B,KAAL,CAAW/G,GAAG,GAAGgH,gBAAjB,IAAqCA,gBAA5C;AACD;AAED,SAASH,SAATA,CAAoB7G,GAApB,EAAiC;EAC/B,OAAOgF,IAAI,CAACiC,IAAL,CAAUjH,GAAG,GAAGgH,gBAAhB,IAAoCA,gBAA3C;AACD","names":["computed","effectScope","nextTick","onScopeDispose","ref","watch","watchEffect","clamp","consoleError","convertToUnit","destructComputed","flipAlign","flipCorner","flipSide","getAxis","getScrollParents","IN_BROWSER","isFixedPosition","nullifyTransforms","parseAnchor","propsFactory","Box","getOverflow","anchorToPoint","getOffset","locationStrategies","static","staticLocationStrategy","connected","connectedLocationStrategy","makeLocationStrategyProps","locationStrategy","type","String","Function","default","validator","val","location","origin","offset","Number","Array","useLocationStrategies","props","data","contentStyles","updateLocation","scope","stop","value","undefined","isActive","run","_props$locationStrate","_locationStrategies$p","window","addEventListener","onResize","passive","removeEventListener","e","getIntrinsicSize","el","contentBox","x","parseFloat","style","left","y","top","activatorFixed","activatorEl","Object","assign","position","preferredAnchor","preferredOrigin","parsedAnchor","isRtl","parsedOrigin","side","align","minWidth","minHeight","maxWidth","maxHeight","map","key","isNaN","Infinity","isArray","split","length","push","observe","observer","ResizeObserver","contentEl","disconnect","requestAnimationFrame","targetBox","getBoundingClientRect","scrollParents","viewportMargin","document","documentElement","getPropertyValue","viewport","reduce","box","rect","scrollBox","width","clientWidth","height","clientHeight","Math","max","min","right","bottom","placement","anchor","checkOverflow","_placement","targetPoint","contentPoint","overflows","available","flipped","resets","_x","_y","axis","hasOverflowX","before","after","hasOverflowY","reset","forEach","newPlacement","flip","newOverflows","transformOrigin","pixelRound","pixelCeil","immediate","round","devicePixelRatio","ceil"],"sources":["../../../src/components/VOverlay/locationStrategies.ts"],"sourcesContent":["// Utilities\nimport { computed, effectScope, nextTick, onScopeDispose, ref, watch, watchEffect } from 'vue'\nimport {\n  clamp,\n  consoleError,\n  convertToUnit,\n  destructComputed,\n  flipAlign,\n  flipCorner,\n  flipSide,\n  getAxis,\n  getScrollParents,\n  IN_BROWSER,\n  isFixedPosition,\n  nullifyTransforms,\n  parseAnchor,\n  propsFactory,\n} from '@/util'\nimport { Box, getOverflow } from '@/util/box'\nimport { anchorToPoint, getOffset } from './util/point'\n\n// Types\nimport type { EffectScope, PropType, Ref } from 'vue'\nimport type { Anchor } from '@/util'\n\nexport interface LocationStrategyData {\n  contentEl: Ref<HTMLElement | undefined>\n  activatorEl: Ref<HTMLElement | undefined>\n  isActive: Ref<boolean>\n  isRtl: Ref<boolean>\n}\n\nconst locationStrategies = {\n  static: staticLocationStrategy, // specific viewport position, usually centered\n  connected: connectedLocationStrategy, // connected to a certain element\n}\n\nexport interface StrategyProps {\n  locationStrategy: keyof typeof locationStrategies | (\n    (\n      data: LocationStrategyData,\n      props: StrategyProps,\n      contentStyles: Ref<Record<string, string>>\n    ) => undefined | { updateLocation: (e: Event) => void }\n  )\n  location: Anchor\n  origin: Anchor | 'auto' | 'overlap'\n  offset?: number | string | number[]\n  maxHeight?: number | string\n  maxWidth?: number | string\n  minHeight?: number | string\n  minWidth?: number | string\n}\n\nexport const makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function] as PropType<StrategyProps['locationStrategy']>,\n    default: 'static',\n    validator: (val: any) => typeof val === 'function' || val in locationStrategies,\n  },\n  location: {\n    type: String as PropType<StrategyProps['location']>,\n    default: 'bottom',\n  },\n  origin: {\n    type: String as PropType<StrategyProps['origin']>,\n    default: 'auto',\n  },\n  offset: [Number, String, Array] as PropType<StrategyProps['offset']>,\n})\n\nexport function useLocationStrategies (\n  props: StrategyProps,\n  data: LocationStrategyData\n) {\n  const contentStyles = ref({})\n  const updateLocation = ref<(e: Event) => void>()\n\n  let scope: EffectScope | undefined\n  watchEffect(async () => {\n    scope?.stop()\n    updateLocation.value = undefined\n\n    if (!(IN_BROWSER && data.isActive.value && props.locationStrategy)) return\n\n    scope = effectScope()\n    await nextTick()\n    scope.run(() => {\n      if (typeof props.locationStrategy === 'function') {\n        updateLocation.value = props.locationStrategy(data, props, contentStyles)?.updateLocation\n      } else {\n        updateLocation.value = locationStrategies[props.locationStrategy](data, props, contentStyles)?.updateLocation\n      }\n    })\n  })\n\n  IN_BROWSER && window.addEventListener('resize', onResize, { passive: true })\n\n  onScopeDispose(() => {\n    IN_BROWSER && window.removeEventListener('resize', onResize)\n    updateLocation.value = undefined\n    scope?.stop()\n  })\n\n  function onResize (e: Event) {\n    updateLocation.value?.(e)\n  }\n\n  return {\n    contentStyles,\n    updateLocation,\n  }\n}\n\nfunction staticLocationStrategy () {\n  // TODO\n}\n\n/** Get size of element ignoring max-width/max-height */\nfunction getIntrinsicSize (el: HTMLElement) {\n  // const scrollables = new Map<Element, [number, number]>()\n  // el.querySelectorAll('*').forEach(el => {\n  //   const x = el.scrollLeft\n  //   const y = el.scrollTop\n  //   if (x || y) {\n  //     scrollables.set(el, [x, y])\n  //   }\n  // })\n\n  // const initialMaxWidth = el.style.maxWidth\n  // const initialMaxHeight = el.style.maxHeight\n  // el.style.removeProperty('max-width')\n  // el.style.removeProperty('max-height')\n\n  /* eslint-disable-next-line sonarjs/prefer-immediate-return */\n  const contentBox = nullifyTransforms(el)\n\n  contentBox.x -= parseFloat(el.style.left || 0)\n  contentBox.y -= parseFloat(el.style.top || 0)\n\n  // el.style.maxWidth = initialMaxWidth\n  // el.style.maxHeight = initialMaxHeight\n  // scrollables.forEach((position, el) => {\n  //   el.scrollTo(...position)\n  // })\n\n  return contentBox\n}\n\nfunction connectedLocationStrategy (data: LocationStrategyData, props: StrategyProps, contentStyles: Ref<Record<string, string>>) {\n  const activatorFixed = isFixedPosition(data.activatorEl.value)\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: 'fixed',\n    })\n  }\n\n  const { preferredAnchor, preferredOrigin } = destructComputed(() => {\n    const parsedAnchor = parseAnchor(props.location, data.isRtl.value)\n    const parsedOrigin =\n      props.origin === 'overlap' ? parsedAnchor\n      : props.origin === 'auto' ? flipSide(parsedAnchor)\n      : parseAnchor(props.origin, data.isRtl.value)\n\n    // Some combinations of props may produce an invalid origin\n    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {\n      return {\n        preferredAnchor: flipCorner(parsedAnchor),\n        preferredOrigin: flipCorner(parsedOrigin),\n      }\n    } else {\n      return {\n        preferredAnchor: parsedAnchor,\n        preferredOrigin: parsedOrigin,\n      }\n    }\n  })\n\n  const [minWidth, minHeight, maxWidth, maxHeight] =\n    (['minWidth', 'minHeight', 'maxWidth', 'maxHeight'] as const).map(key => {\n      return computed(() => {\n        const val = parseFloat(props[key]!)\n        return isNaN(val) ? Infinity : val\n      })\n    })\n\n  const offset = computed(() => {\n    if (Array.isArray(props.offset)) {\n      return props.offset\n    }\n    if (typeof props.offset === 'string') {\n      const offset = props.offset.split(' ').map(parseFloat)\n      if (offset.length < 2) offset.push(0)\n      return offset\n    }\n    return typeof props.offset === 'number' ? [props.offset, 0] : [0, 0]\n  })\n\n  let observe = false\n  if (IN_BROWSER) {\n    const observer = new ResizeObserver(() => {\n      if (observe) updateLocation()\n    })\n    observer.observe(data.activatorEl.value!)\n    observer.observe(data.contentEl.value!)\n\n    onScopeDispose(() => {\n      observer.disconnect()\n    })\n  }\n\n  // eslint-disable-next-line max-statements\n  function updateLocation () {\n    observe = false\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => observe = true)\n    })\n\n    const targetBox = data.activatorEl.value!.getBoundingClientRect()\n    const contentBox = getIntrinsicSize(data.contentEl.value!)\n    const scrollParents = getScrollParents(data.contentEl.value)\n    const viewportMargin = 12\n\n    if (!scrollParents.length) {\n      scrollParents.push(document.documentElement)\n      if (!(data.contentEl.value!.style.top && data.contentEl.value!.style.left)) {\n        contentBox.x += parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0)\n        contentBox.y += parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0)\n      }\n    }\n\n    const viewport = scrollParents.reduce<Box>((box: Box | undefined, el) => {\n      const rect = el.getBoundingClientRect()\n      const scrollBox = new Box({\n        x: el === document.documentElement ? 0 : rect.x,\n        y: el === document.documentElement ? 0 : rect.y,\n        width: el.clientWidth,\n        height: el.clientHeight,\n      })\n\n      if (box) {\n        return new Box({\n          x: Math.max(box.left, scrollBox.left),\n          y: Math.max(box.top, scrollBox.top),\n          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),\n          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top),\n        })\n      }\n      return scrollBox\n    }, undefined!)\n    viewport.x += viewportMargin\n    viewport.y += viewportMargin\n    viewport.width -= viewportMargin * 2\n    viewport.height -= viewportMargin * 2\n\n    let placement = {\n      anchor: preferredAnchor.value,\n      origin: preferredOrigin.value,\n    }\n\n    function checkOverflow (_placement: typeof placement) {\n      const box = new Box(contentBox)\n      const targetPoint = anchorToPoint(_placement.anchor, targetBox)\n      const contentPoint = anchorToPoint(_placement.origin, box)\n\n      let { x, y } = getOffset(targetPoint, contentPoint)\n\n      switch (_placement.anchor.side) {\n        case 'top': y -= offset.value[0]; break\n        case 'bottom': y += offset.value[0]; break\n        case 'left': x -= offset.value[0]; break\n        case 'right': x += offset.value[0]; break\n      }\n\n      switch (_placement.anchor.align) {\n        case 'top': y -= offset.value[1]; break\n        case 'bottom': y += offset.value[1]; break\n        case 'left': x -= offset.value[1]; break\n        case 'right': x += offset.value[1]; break\n      }\n\n      box.x += x\n      box.y += y\n\n      box.width = Math.min(box.width, maxWidth.value)\n      box.height = Math.min(box.height, maxHeight.value)\n\n      const overflows = getOverflow(box, viewport)\n\n      return { overflows, x, y }\n    }\n\n    let x = 0; let y = 0\n    const available = { x: 0, y: 0 }\n    const flipped = { x: false, y: false }\n    let resets = -1\n    while (true) {\n      if (resets++ > 10) {\n        consoleError('Infinite loop detected in connectedLocationStrategy')\n        break\n      }\n\n      const { x: _x, y: _y, overflows } = checkOverflow(placement)\n\n      x += _x\n      y += _y\n\n      contentBox.x += _x\n      contentBox.y += _y\n\n      // flip\n      {\n        const axis = getAxis(placement.anchor)\n        const hasOverflowX = overflows.x.before || overflows.x.after\n        const hasOverflowY = overflows.y.before || overflows.y.after\n\n        let reset = false\n        ;['x', 'y'].forEach(key => {\n          if (\n            (key === 'x' && hasOverflowX && !flipped.x) ||\n            (key === 'y' && hasOverflowY && !flipped.y)\n          ) {\n            const newPlacement = { anchor: { ...placement.anchor }, origin: { ...placement.origin } }\n            const flip = key === 'x'\n              ? axis === 'y' ? flipAlign : flipSide\n              : axis === 'y' ? flipSide : flipAlign\n            newPlacement.anchor = flip(newPlacement.anchor)\n            newPlacement.origin = flip(newPlacement.origin)\n            const { overflows: newOverflows } = checkOverflow(newPlacement)\n            if (\n              (newOverflows[key].before <= overflows[key].before &&\n                newOverflows[key].after <= overflows[key].after) ||\n              (newOverflows[key].before + newOverflows[key].after <\n                (overflows[key].before + overflows[key].after) / 2)\n            ) {\n              placement = newPlacement\n              reset = flipped[key] = true\n            }\n          }\n        })\n        if (reset) continue\n      }\n\n      // shift\n      if (overflows.x.before) {\n        x += overflows.x.before\n        contentBox.x += overflows.x.before\n      }\n      if (overflows.x.after) {\n        x -= overflows.x.after\n        contentBox.x -= overflows.x.after\n      }\n      if (overflows.y.before) {\n        y += overflows.y.before\n        contentBox.y += overflows.y.before\n      }\n      if (overflows.y.after) {\n        y -= overflows.y.after\n        contentBox.y -= overflows.y.after\n      }\n\n      // size\n      {\n        const overflows = getOverflow(contentBox, viewport)\n        available.x = viewport.width - overflows.x.before - overflows.x.after\n        available.y = viewport.height - overflows.y.before - overflows.y.after\n\n        x += overflows.x.before\n        contentBox.x += overflows.x.before\n        y += overflows.y.before\n        contentBox.y += overflows.y.before\n      }\n\n      break\n    }\n\n    const axis = getAxis(placement.anchor)\n\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': `${placement.anchor.side} ${placement.anchor.align}`,\n      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,\n      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,\n      top: convertToUnit(pixelRound(y)),\n      left: convertToUnit(pixelRound(x)),\n      minWidth: convertToUnit(axis === 'y' ? Math.min(minWidth.value, targetBox.width) : minWidth.value),\n      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),\n      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value))),\n    })\n  }\n\n  watch(\n    () => [\n      preferredAnchor.value,\n      preferredOrigin.value,\n      props.offset,\n      props.minWidth,\n      props.minHeight,\n      props.maxWidth,\n      props.maxHeight,\n    ],\n    () => updateLocation(),\n    { immediate: !activatorFixed }\n  )\n\n  if (activatorFixed) nextTick(() => updateLocation())\n  requestAnimationFrame(() => {\n    if (contentStyles.value.maxHeight) updateLocation()\n  })\n\n  return { updateLocation }\n}\n\nfunction pixelRound (val: number) {\n  return Math.round(val * devicePixelRatio) / devicePixelRatio\n}\n\nfunction pixelCeil (val: number) {\n  return Math.ceil(val * devicePixelRatio) / devicePixelRatio\n}\n"]},"metadata":{},"sourceType":"module"}